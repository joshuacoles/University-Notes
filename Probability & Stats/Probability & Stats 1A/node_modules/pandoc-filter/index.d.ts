/**
 * type of the JSON file (new syntax, old syntax was just the array of blocks)
 */
export declare type PandocJson = {
    blocks: Block[];
    "pandoc-api-version": number[];
    meta: PandocMetaMap;
};
declare type FAReturn = void | AnyElt | Array<AnyElt>;
export declare type SingleFilterActionAsync = (ele: AnyElt, format: string, meta: PandocMetaMap) => Promise<FAReturn> | FAReturn;
export declare type ArrayFilterActionAsync = (ele: AnyElt[], format: string, meta: PandocMetaMap) => Promise<Array<AnyElt>> | Array<AnyElt>;
/**
 * allow both a function that filters single elements (compat with old version), as well as passing two filter functions:
 * one that will be called with every list of children and can return a new list of children to replace them,
 * and one that acts on single elements
 */
export declare type FilterActionAsync = SingleFilterActionAsync | {
    array?: ArrayFilterActionAsync;
    single?: SingleFilterActionAsync;
};
/** list of key-value attributes */
export declare type AttrList = Array<[string, string]>;
/** [id, classes, list of key-value attributes] */
export declare type Attr = [string, Array<string>, AttrList];
export declare type MathType = {
    t: "DisplayMath" | "InlineMath";
};
export declare type QuoteType = {
    t: "SingleQuote" | "DoubleQuote";
};
/** [url, title] */
export declare type Target = [string, string];
/** output file format */
export declare type Format = string;
export declare type CitationMode = {
    t: "AuthorInText" | "SuppressAuthor" | "NormalCitation";
};
export declare type Citation = {
    citationId: string;
    citationPrefix: Array<Inline>;
    citationSuffix: Array<Inline>;
    citationMode: CitationMode;
    citationNoteNum: number;
    citationHash: number;
};
export declare type ListNumberStyle = {
    t: "DefaultStyle" | "Example" | "Decimal" | "LowerRoman" | "UpperRoman" | "LowerAlpha" | "UpperAlpha";
};
export declare type ListNumberDelim = {
    t: "DefaultDelim" | "Period" | "OneParen" | "TwoParens";
};
export declare type ListAttributes = [number, ListNumberStyle, ListNumberDelim];
export declare type Alignment = {
    t: "AlignLeft" | "AlignRight" | "AlignCenter" | "AlignDefault";
};
export declare type TableCell = Array<Block>;
export declare type EltMap = {
    Str: string;
    Emph: Array<Inline>;
    Strong: Array<Inline>;
    Strikeout: Array<Inline>;
    Superscript: Array<Inline>;
    Subscript: Array<Inline>;
    SmallCaps: Array<Inline>;
    Quoted: [QuoteType, Array<Inline>];
    Cite: [Array<Citation>, Array<Inline>];
    Code: [Attr, string];
    Space: undefined;
    SoftBreak: undefined;
    LineBreak: undefined;
    Math: [MathType, string];
    RawInline: [Format, string];
    Link: [Attr, Array<Inline>, Target];
    Image: [Attr, Array<Inline>, Target];
    Note: Array<Block>;
    Span: [Attr, Array<Inline>];
    Plain: Array<Inline>;
    Para: Array<Inline>;
    LineBlock: Array<Array<Inline>>;
    CodeBlock: [Attr, string];
    RawBlock: [Format, string];
    BlockQuote: Array<Block>;
    OrderedList: [ListAttributes, Array<Array<Block>>];
    BulletList: Array<Array<Block>>;
    DefinitionList: Array<[Array<Inline>, Array<Array<Block>>]>;
    Header: [number, Attr, Array<Inline>];
    HorizontalRule: undefined;
    Table: [Array<Inline>, Array<Alignment>, Array<number>, Array<TableCell>, Array<Array<TableCell>>];
    Div: [Attr, Array<Block>];
    Null: undefined;
};
export declare type EltType = keyof EltMap;
export declare type Elt<A extends EltType> = {
    t: A;
    c: EltMap[A];
};
export declare type AnyElt = Inline | Block;
export declare type Inline = Elt<"Str"> | Elt<"Emph"> | Elt<"Strong"> | Elt<"Strikeout"> | Elt<"Superscript"> | Elt<"Subscript"> | Elt<"SmallCaps"> | Elt<"Quoted"> | Elt<"Cite"> | Elt<"Code"> | Elt<"Space"> | Elt<"SoftBreak"> | Elt<"LineBreak"> | Elt<"Math"> | Elt<"RawInline"> | Elt<"Link"> | Elt<"Image"> | Elt<"Note"> | Elt<"Span">;
export declare type Block = Elt<"Plain"> | Elt<"Para"> | Elt<"LineBlock"> | Elt<"CodeBlock"> | Elt<"RawBlock"> | Elt<"BlockQuote"> | Elt<"OrderedList"> | Elt<"BulletList"> | Elt<"DefinitionList"> | Elt<"Header"> | Elt<"HorizontalRule"> | Elt<"Table"> | Elt<"Div"> | Elt<"Null">;
export declare type Tree = Array<Block | Inline>;
/** meta information about document, mostly from markdown frontmatter
 * https://hackage.haskell.org/package/pandoc-types-1.20/docs/Text-Pandoc-Definition.html#t:MetaValue
 */
export declare type PandocMetaValue = {
    t: "MetaMap";
    c: PandocMetaMap;
} | {
    t: "MetaList";
    c: Array<PandocMetaValue>;
} | {
    t: "MetaBool";
    c: boolean;
} | {
    t: "MetaInlines";
    c: Inline[];
} | {
    t: "MetaString";
    c: string;
} | {
    t: "MetaBlocks";
    c: Block[];
};
export declare type PandocMetaMap = Record<string, PandocMetaValue>;
/**
 * Converts an action into a filter that reads a JSON-formatted pandoc
 * document from stdin, transforms it by walking the tree with the action, and
 * returns a new JSON-formatted pandoc document to stdout. The argument is a
 * function action(key, value, format, meta), where key is the type of the
 * pandoc object (e.g. 'Str', 'Para'), value is the contents of the object
 * (e.g. a string for 'Str', a list of inline elements for 'Para'), format is
 * the target output format (which will be taken for the first command
 * line argument if present), and meta is the document's metadata. If the
 * function returns None, the object to which it applies will remain
 * unchanged. If it returns an object, the object will be replaced. If it
 * returns a list, the list will be spliced in to the list to which the target
 * object belongs. (So, returning an empty list deletes the object.)
 *
 * @param  {Function} action Callback to apply to every object
 */
export declare function toJSONFilter(action: FilterActionAsync): Promise<void>;
/**
 * Walk a tree, applying an action to every object.
 * @param  {Object}   x      The object to traverse
 * @param  {Function} action Callback to apply to each item
 * @param  {String}   format Output format
 * @param  {Object}   meta   Pandoc metadata
 * @return {Object}          The modified tree
 */
export declare function walk(x: unknown, action: FilterActionAsync, format: Format, meta: PandocMetaMap): Promise<unknown>;
export declare function walkSync(x: unknown, action: (ele: AnyElt, format: string, meta: PandocMetaMap) => FAReturn, format: Format, meta: PandocMetaMap): any;
/**
 * Walks the tree x and returns concatenated string content, leaving out all
 * formatting.
 * @param  {Object} x The object to walk
 * @return {String}   JSON string
 */
export declare function stringify(x: Tree | AnyElt | {
    t: "MetaString";
    c: string;
}): string;
/**
 * Returns an attribute list, constructed from the dictionary attrs.
 * @param  {Object} attrs Attribute dictionary
 * @return {Array}        Attribute list
 */
export declare function attributes(attrs: {
    id?: string;
    classes?: string[];
    [k: string]: any;
}): Attr;
/**
 * Filter the given object
 */
export declare function filter(data: PandocJson, action: FilterActionAsync, format: Format): Promise<PandocJson>;
declare type RawMetaRecord = {
    [name: string]: RawMeta;
};
declare type RawMeta = string | boolean | RawMetaRecord | Array<RawMeta>;
/** `.meta` in the pandoc json format describes the markdown frontmatter yaml as an AST as described in
 *  https://hackage.haskell.org/package/pandoc-types-1.20/docs/Text-Pandoc-Definition.html#t:MetaValue
 *
 * this function converts a raw object to a pandoc meta AST object
 **/
export declare function rawToMeta(e: RawMeta): PandocMetaValue;
export declare function metaToRaw(m: PandocMetaValue): RawMeta;
/** meta root object is a map */
export declare function metaMapToRaw(c: PandocMetaMap): RawMetaRecord;
export declare const Plain: (args_0: Inline[]) => Elt<"Plain">;
export declare const Para: (args_0: Inline[]) => Elt<"Para">;
export declare const CodeBlock: (args_0: Attr, args_1: string) => Elt<"CodeBlock">;
export declare const RawBlock: (args_0: string, args_1: string) => Elt<"RawBlock">;
export declare const BlockQuote: (args_0: Block[]) => Elt<"BlockQuote">;
export declare const OrderedList: (args_0: ListAttributes, args_1: Block[][]) => Elt<"OrderedList">;
export declare const BulletList: (args_0: Block[][]) => Elt<"BulletList">;
export declare const DefinitionList: (args_0: [Inline[], Block[][]][]) => Elt<"DefinitionList">;
export declare const Header: (args_0: number, args_1: Attr, args_2: Inline[]) => Elt<"Header">;
export declare const HorizontalRule: () => Elt<"HorizontalRule">;
export declare const Table: (args_0: Inline[], args_1: Alignment[], args_2: number[], args_3: TableCell[], args_4: TableCell[][]) => Elt<"Table">;
export declare const Div: (args_0: Attr, args_1: Block[]) => Elt<"Div">;
export declare const Null: () => Elt<"Null">;
export declare const Str: (args_0: string) => Elt<"Str">;
export declare const Emph: (args_0: Inline[]) => Elt<"Emph">;
export declare const Strong: (args_0: Inline[]) => Elt<"Strong">;
export declare const Strikeout: (args_0: Inline[]) => Elt<"Strikeout">;
export declare const Superscript: (args_0: Inline[]) => Elt<"Superscript">;
export declare const Subscript: (args_0: Inline[]) => Elt<"Subscript">;
export declare const SmallCaps: (args_0: Inline[]) => Elt<"SmallCaps">;
export declare const Quoted: (args_0: QuoteType, args_1: Inline[]) => Elt<"Quoted">;
export declare const Cite: (args_0: Citation[], args_1: Inline[]) => Elt<"Cite">;
export declare const Code: (args_0: Attr, args_1: string) => Elt<"Code">;
export declare const Space: () => Elt<"Space">;
export declare const LineBreak: () => Elt<"LineBreak">;
export declare const Formula: (args_0: MathType, args_1: string) => Elt<"Math">;
export declare const RawInline: (args_0: string, args_1: string) => Elt<"RawInline">;
export declare const Link: (args_0: Attr, args_1: Inline[], args_2: Target) => Elt<"Link">;
export declare const Image: (args_0: Attr, args_1: Inline[], args_2: Target) => Elt<"Image">;
export declare const Note: (args_0: Block[]) => Elt<"Note">;
export declare const Span: (args_0: Attr, args_1: Inline[]) => Elt<"Span">;
export declare const stdio: typeof toJSONFilter;
export {};
